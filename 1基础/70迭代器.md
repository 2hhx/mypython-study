[TOC]

# 迭代器

迭代器：迭代的工具，迭代是更新换代，就像传宗接代一样。单纯的重复就不算迭代。迭代的每一次结果都是基于上一次结果来的。

# 一、可迭代对象

python中一切皆对象，如

```python
# 可迭代(具有__iter__方法)   对象

x = 1  # 不可迭代对象(数字类型为不可迭代对象)

s = 'nick'  # 可迭代对象
s.__iter__()
lt = [1, 2, 3]  # 可迭代对象
dic = {'a': 1, 'b': 2}  # 可迭代对象
tup = (1,)  # 元组只有一个元素必须得加逗号# 可迭代对象
se = {1, 2, 3}  # 可迭代对象
f = open('time.py')  # 可迭代对象(文件类为可迭代器对象)


def func():  # 不可迭代对象
    pass

```

总结：

有__iter__()方法的对象就是可迭代对象,然后出了数字类型和函数之外都是可迭代对象,通过\__next\__进行迭代

```python
# 迭代器对象: 具有__iter__以及__next__方法的叫做迭代器对象
s = 'nick'  # 可迭代对象,不属于迭代器对象, 基于索引(基于上一次结果)通过__next__进行迭代
s.__iter__()
lt = [1, 2, 3]  # 可迭代对象,不属于迭代器对象
dic = {'a': 1, 'b': 2}  # 可迭代对象,不属于迭代器对象
tup = (1,)  # 元组只有一个元素必须得加逗号# 可迭代对象,不属于迭代器对象
se = {1, 2, 3}  # 可迭代对象,不属于迭代器对象
f = open('time.py')  # 可迭代对象,迭代器对象


# 只有文件是迭代器对象
```

# 二、可迭代器对象

只有字符串和列表都是依赖索引取值的，而其他的可迭代对象都是无法依赖索引取值的。因此我们得找到一个方法能让其他的可迭代对象不依赖索引取值。

在找到该方法前，首先我们给出迭代器对象的概念：可迭代的对象执行`__iter__`方法得到的返回值。并且可迭代对象会有一个`__next__`方法。

总结：

迭代器对象：执行可迭代对象的`__iter__`方法，拿到的返回值就是迭代器对象。

特点：

1. 内置`__next__`方法，执行该方法会拿到迭代器对象中的一个值
2. 内置有`__iter__`方法，执行该方法会拿到迭代器本身
3. 文件本身就是迭代器对象。

缺点：

1. 取值麻烦，只能一个一个取，并且只能往后取，值取了就没了
2. 无法使用len()方法获取长度



# 三、for循环原理

因为迭代器使用`__iter__`后还是迭代器本身，因此for循环不用考虑in后的对象是可迭代对象还是迭代器对象。

由于对可迭代对象使用`__iter__`方法后变成一个迭代器对象，这个迭代器对象只是占用了一小块内存空间，他只有使用`__next__`后才会吐出一个一个值。如`lis = [1,2,3,4,5,...]`相当于一个一个鸡蛋，而`lis = [1,2,3,4,5,...].__iter__`相当于一只老母鸡，如果你需要蛋，只需要`__next__`即可。

```python
lt = [1,2,3]
lt_iter = lt.__iter__()
while 1:
    try:
        print(lt_iter.__next__())
    except StopIteration:
        break
# 1. 首先使用iter把lt变成迭代器对象;对于文件也要使用iter方法吧文件再一次iter下
# 2. 然后使用next方法进行迭代取值
# 3. 判断StopIteration异常,遇到异常终止
```

