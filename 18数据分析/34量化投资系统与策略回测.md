# 学习目标

  * 事件驱动的交易系统构建：介绍交易系统平台的基本架构与实现。包括事件驱动软件概述、交易系统的组成部分编程，事件驱动的交易执行。
  * 交易策略实现：移动平均跨越策略、S&P500预测交易、均值回复的股权配对交易、
  * 策略优化：参数优化、模型选择、策略优化

# 概述

## 自动化交易的优缺点

算法交易，一般被定义为使用自动化的系统来进行交易，其用一种预先设定的方式运行，通常没有人为的干预。“没有人为干预”这一点是非常重要的。算法策略是在交易开始之前进行设计的，在交易的时候没有任何的人工干预。与常规交易相比，算法交易的优势体现在：

  * 历史验证：这是设计算法交易程序实现交易的最大优势就是它的交易业绩可以由历史数据来进行验证，人们往往期望这种历史业绩可以代表将来。历史数据验证的过程称为回测，回测使得策略的统计特性被决定，提供了关于策略是否可以获利的重要信息。
  * 有效性：算法交易在多数时候比主观的方法更为有效，完全自动化的交易系统不经常需要人们去监测市场的价格行为或者是消息。这使得投资者可以有时间开发更多的交易策略，来实现获利。对于风险管理来说，算法交易实施系统化的交易策略，可以动态的对杠杆以及风险因子进行调整，有效的对实时市场的动态做出反应。这在主观交易中是不容易实现的，因为交易者通常不能连续的计算风险，而必须在观测市场镇南关有所间断
  * 没有扭曲性投入：所谓扭曲性投入指的是对头寸进行的调整。主观交易的时候因为恐惧和贪婪可能导致过多的扭曲交易，系统化交易中这种情况比较少，提升了策略的业绩。只是在出现某些大的变化的时候，需要对参数进行调整。
  * 可比较：系统化交易提供了历史和目前业绩的统计信息，可以方便的计算价值的增长，风险，交易频率等指标，这样方便我们去比较业绩。这与在主观交易中只能根据P&L来比较业绩是有差别的，那里可能存在回撤的风险。
  * 高频交易：高频交易需要较高的效率，必须自动化的进行，有很多高频交易的交易频率是超过了人们的反应成都。这样的策略只能用算法交易进行处理。

自动化交易的缺点：

  * 资本的需求：算法交易需要大量的投入，支持算法交易的佣金通常较高，虽然目前已经有了一定的改变。另外，获取日内交易的数据通常也是不便宜的。每月大约在300至500美元之间。而且还需要稳定的互联网连接和速度较快的电脑。
  * 编程和科学技术：虽然有一些现成的系统化交易平台，例如Quantopian，QuantConnect以及TradeStation可以帮助我们减轻编程的压力，但是有的并不支持实时交易。这样通常还是需要系统化交易者具有一定的编程和科学建模技术。在本课程的学习中，我们将介绍一些不同的交易策略，如果你掌握有一些数值建模的技术，那么对于建模部分的介绍会发现比较容易理解。大部分的技术在Python中都可以直接实现，节省了大量的开发时间，我们要做的就是将数据分析与执行库结合在一起来构建算法交易系统。

## 为什么使用python进行自动化交易

为什么使用Python？Python是一种高级语言，设计用来提升开发的速度，它包含大量的库来进行各种科学计算。它也是资产管理机构和投资银行通常选用的语言。使用Python进行算法交易有以下几个好处：

  * 学习：相对于其他语言，比如C++, Python是比骄傲容易学习的。基本的Python操作几周就可以掌握。
  * 库：Python拥有大量的用于计算的库，减少了实现的时间和出现BUG的机会。特别的，你可以使用NumPy（向量操作），Scipy（最优化），pandas（时间序列分析），statsmodel（统计建模），scikit-learn（机器学习）,Ipython（交互式开发）以及matplotlib（可视化）。
  * 开发的速度：Python在速度方面有优势，通常写Python代码类似于伪代码，类似于Ipython的交互式工具也可以在不牺牲稳健性的前提下获得较高的开发速度。
  * 执行的速度：虽然不像C++那样快，Python还是提供了优化执行速度的模块，例如Cython等，通过使代码变得复杂一点，可以提升执行的速度。
  * 交易的执行：较大的券商都有Python插件，例如Interactive Brokers（Ibypy），Python还可以很容易在必要的时候使用FIX协议。
  * 成本/授权，Python是免费，开源的和跨平台的。

# 事件驱动的交易引擎实现

## 事件驱动软件

在我们开发回测模块的时候，我们需要理解事件驱动系统的概念。视频游戏提供了事件驱动软件的一个很好例子。一个视频游戏有多个组成部分，在实时彼此之间有所交互。这是通过运行无限的循环，称为事件循环和游戏循环来实现的。在每一个游戏循环中，函数被调用，接收最近的事件，这个事件是由某些之前的游戏行为产生的。基于事件的不同，可能是单击鼠标或者是键盘，然后会采取相应的行为，或者终止循环，或者生成某些更新的事件。这个过程会继续。

事件驱动的系统提供了如下的好处：

  * 代码的重用：事件驱动的回测程序，在设计上可以被用于历史回测以及实际交易，只需要简单的进行转换。而对于向量化的回测程序而言，所有的数据必须一次性获得来进行统计分析。
  * 向前偏差：事件驱动的回测程序不会产生向前偏差，因为收到的市场数据被看作为事件，而作为后期行为的基础。这样可以使用市场数据来填充事件驱动回测，复制了订单管理和资产组合系统的行为。
  * 现实性：事件驱动回测程序允许对交易如何执行以及交易成本进行个性化，直接可以处理基本的市价和限价订单，以及市场基于开盘（MOO）以及市场基于收盘（MOC），因为我们可以构建一个个性化的交易处理程序。

虽然事件驱动的交易系统有很多好处，但是也有缺点，主要是在构造方面比较复杂，检验也是。有一些改变的部分会产生BUG，这样就需要使用测试驱动的开发。另外它运行也要慢一些，因为没有利用到向量化的好处

## 事件驱动交易软件的组成

  * 事件：事件是事件驱动系统的基础类。它包含一个类型（例如“MARKET”，“SIGNAL”，“ORDER”或”FILL”），确定在事件循环中需要处理的方式。  
事件队列：事件队列是Python内存中的队列对象，存储所有的由系统的其他部分生成的事件子类对象。

  * DataHandler：DataHandler是一个抽象类，代表了历史和实际市场数据的一个接口。这提供了很强的灵活性，因为Startegy和Portfoli模块都可以进行重用，DataHandler会产生一个新的MarketEvent，基于系统的每一次心跳。
  * Strategy：策略类也是一个ABC，代表使用市场数据生成对应的SignalEvents的接口，最终由Portfolio类来使用。SignalEvent包括一个标的代码，一个方向（LONG或者SHORT），以及一个时间戳。
  * Portfolio：这是一个类的层次结构，处理订单管理以及策略中的目前和后续的头寸。它还进行资产组合的风险管理，包括行业暴露和头寸的大小。在一个更为专业的实现中，这可能会被代理给RiskMangagement类。Portfolio类接收Queue中的SignalEvents，生成OrderEvents加入到序列中。
  * ExecutionHandler：ExcecutionHandler模拟一个到券商的连接。它的工作室从Queue中取出OrderEvents，然后执行，或者通过一个模拟的方法，或者是通过实际执行。一旦订单被执行，处理器生成FillEvents，描述交易的细节，包括费用，佣金，以及价格影响等。
  * 回测：所有这些成本都被包装到事件循环中，处理所有的事件类型并路由到合适的组成成分

## Events类

....

